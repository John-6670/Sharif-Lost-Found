<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/spring-api/nexus/JWT_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/spring-api/nexus/JWT_SETUP.md" />
              <option name="updatedContent" value="# JWT Token Verification Setup&#10;&#10;## Overview&#10;This Spring Boot application does **NOT** handle user authentication (login/register). Authentication is handled by the Django backend. This service only **verifies** JWT tokens issued by Django.&#10;&#10;## How it Works&#10;&#10;### 1. Authentication Flow (Django Backend)&#10;- User registers/logs in through Django API&#10;- Django generates JWT token: `header.payload.signature`&#10;- Django returns the JWT token to the user&#10;&#10;### 2. Protected Endpoint Access (Spring Backend)&#10;- User sends request to Spring API with JWT token in header:&#10;  ```&#10;  Authorization: Bearer &lt;jwt-token&gt;&#10;  ```&#10;- Spring's `JwtAuthenticationFilter` intercepts the request&#10;- Token is validated using the shared secret key&#10;- If valid, user information is extracted and request proceeds&#10;- If invalid, request is rejected with 401 Unauthorized&#10;&#10;## Configuration&#10;&#10;### Important: JWT Secret Key&#10;The JWT secret key **MUST** be identical in both Django and Spring applications.&#10;&#10;**Spring Configuration** (`application.properties`):&#10;```properties&#10;jwt.secret=YourSuperSecretKeyForJWTTokenGenerationMustBeAtLeast256BitsLong123456789&#10;jwt.expiration=86400000&#10;```&#10;&#10;**Django Configuration** (should match):&#10;Ensure your Django JWT settings use the same secret key.&#10;&#10;## Protected Endpoints&#10;&#10;All endpoints under `/api/**` require JWT authentication:&#10;- `POST /api/product` - Add a new product&#10;- `PUT /api/product/{id}` - Update a product&#10;- `DELETE /api/product/{id}` - Delete a product&#10;&#10;## How to Use&#10;&#10;### Frontend Request Example&#10;```javascript&#10;// After login from Django, store the token&#10;const token = response.data.token;&#10;&#10;// Use token for Spring API calls&#10;fetch('http://spring-api-url/api/product', {&#10;  method: 'POST',&#10;  headers: {&#10;    'Authorization': `Bearer ${token}`,&#10;    'Content-Type': 'application/json'&#10;  },&#10;  body: JSON.stringify(productData)&#10;});&#10;```&#10;&#10;### Testing with curl&#10;```bash&#10;# Add product (requires JWT token)&#10;curl -X POST http://localhost:8080/api/product \&#10;  -H &quot;Authorization: Bearer &lt;your-jwt-token&gt;&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;productName&quot;:&quot;Lost Wallet&quot;,&quot;description&quot;:&quot;Black leather wallet&quot;,&quot;typeOfReport&quot;:&quot;LOST&quot;,...}'&#10;```&#10;&#10;## Security Components&#10;&#10;### 1. JwtUtil&#10;- Validates JWT tokens&#10;- Extracts user email from token&#10;- Verifies token signature using shared secret&#10;&#10;### 2. JwtAuthenticationFilter&#10;- Intercepts all requests&#10;- Extracts JWT token from Authorization header&#10;- Validates token and sets authentication context&#10;&#10;### 3. SecurityConfig&#10;- Configures which endpoints require authentication&#10;- Sets up stateless session (no server-side session storage)&#10;- Integrates JWT filter into security chain&#10;&#10;## Development Notes&#10;&#10;- H2 console is accessible at `/h2-console` (no authentication required)&#10;- All other `/api/**` endpoints require valid JWT token&#10;- Sessions are stateless - each request must include the token&#10;- Token expiration is handled by Django&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/spring-api/nexus/SECURITY_IMPLEMENTATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/spring-api/nexus/SECURITY_IMPLEMENTATION.md" />
              <option name="updatedContent" value="# User Authentication &amp; Authorization Implementation&#10;&#10;## ✅ IMPLEMENTATION STATUS: **COMPLETE**&#10;&#10;The requirement &quot;only logged-in users can create lost or found items, with proper ownership and accountability&quot; is **FULLY IMPLEMENTED**.&#10;&#10;---&#10;&#10;## Security Features Implemented&#10;&#10;### 1. **Authentication (JWT Token Verification)**&#10;- All `/api/**` endpoints require a valid JWT token&#10;- Unauthenticated requests are rejected with `401 Unauthorized`&#10;- JWT tokens are issued by Django backend after successful login&#10;- Spring backend verifies the token signature using the shared secret key&#10;&#10;**Configuration:**&#10;- File: `SecurityConfig.java`&#10;- Protected routes: `/api/**` (all product endpoints)&#10;- Filter: `JwtAuthenticationFilter` intercepts and validates tokens&#10;&#10;### 2. **Item Ownership on Creation**&#10;When a user creates a lost/found item:&#10;- The system extracts the **authenticated user's email** from the JWT token&#10;- The user cannot fake or specify a different email in the request&#10;- The item is automatically associated with the logged-in user&#10;- User accountability is guaranteed at creation time&#10;&#10;**Implementation:**&#10;```java&#10;// ProductController.java - addProduct method&#10;Authentication authentication = SecurityContextHolder.getContext().getAuthentication();&#10;String authenticatedUserEmail = authentication.getName();&#10;ProductResponseDto response = productService.addProduct(request, authenticatedUserEmail);&#10;```&#10;&#10;### 3. **Authorization on Update/Delete**&#10;Users can only modify or delete their own items:&#10;- Before updating/deleting, the system checks if the product belongs to the authenticated user&#10;- If ownership check fails, throws `SecurityException: &quot;You are not authorized to...&quot;`&#10;- Returns `403 Forbidden` to unauthorized users&#10;&#10;**Implementation:**&#10;```java&#10;// ProductServiceImp.java&#10;if (!foundProduct.getUser().getEmail().equals(authenticatedUserEmail)) {&#10;    throw new SecurityException(&quot;You are not authorized to delete this product&quot;);&#10;}&#10;```&#10;&#10;### 4. **Ownership Transfer Prevention**&#10;- Users cannot change the owner of an item after creation&#10;- The `userEmail` field in update requests is ignored&#10;- Items are permanently linked to their creator&#10;&#10;---&#10;&#10;## How It Works: Complete Flow&#10;&#10;### Creating an Item (POST /api/product)&#10;&#10;1. **User logs in via Django** → receives JWT token&#10;2. **User sends request to Spring API:**&#10;   ```http&#10;   POST /api/product&#10;   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&#10;   Content-Type: application/json&#10;&#10;   {&#10;     &quot;productName&quot;: &quot;Lost Wallet&quot;,&#10;     &quot;description&quot;: &quot;Black leather wallet&quot;,&#10;     &quot;typeOfReport&quot;: &quot;LOST&quot;,&#10;     &quot;lostOrFoundTime&quot;: &quot;2026-01-02T10:30:00&quot;,&#10;     &quot;locationX&quot;: 40.7128,&#10;     &quot;locationY&quot;: -74.0060&#10;   }&#10;   ```&#10;&#10;3. **JWT Filter validates token:**&#10;   - Extracts token from `Authorization` header&#10;   - Verifies signature with secret key&#10;   - Extracts user email from token payload&#10;   - Sets authentication in `SecurityContext`&#10;&#10;4. **Controller receives request:**&#10;   - Extracts authenticated user email from `SecurityContext`&#10;   - Passes it to the service layer&#10;&#10;5. **Service creates product:**&#10;   - Looks up user by authenticated email&#10;   - Creates product linked to that user&#10;   - Saves to database&#10;&#10;6. **Response:**&#10;   ```json&#10;   {&#10;     &quot;success&quot;: true,&#10;     &quot;message&quot;: &quot;Product added successfully&quot;,&#10;     &quot;data&quot;: {&#10;       &quot;id&quot;: 1,&#10;       &quot;productName&quot;: &quot;Lost Wallet&quot;,&#10;       &quot;userEmail&quot;: &quot;john@example.com&quot;,&#10;       ...&#10;     }&#10;   }&#10;   ```&#10;&#10;### Updating an Item (PUT /api/product/{id})&#10;&#10;1. User sends update request with JWT token&#10;2. System verifies JWT token&#10;3. System checks: `product.user.email == authenticatedUserEmail`&#10;4. If match → update proceeds&#10;5. If no match → throws `SecurityException` (403 Forbidden)&#10;&#10;### Deleting an Item (DELETE /api/product/{id})&#10;&#10;1. User sends delete request with JWT token&#10;2. System verifies JWT token&#10;3. System checks: `product.user.email == authenticatedUserEmail`&#10;4. If match → deletion proceeds&#10;5. If no match → throws `SecurityException` (403 Forbidden)&#10;&#10;---&#10;&#10;## Security Guarantees&#10;&#10;✅ **No anonymous item creation** - JWT token required for all operations  &#10;✅ **No identity spoofing** - User email comes from verified JWT token, not request body  &#10;✅ **No unauthorized modifications** - Users can only modify their own items  &#10;✅ **No ownership transfer** - Items permanently belong to their creator  &#10;✅ **Full accountability** - Every item is traceable to its creator via user_id foreign key  &#10;&#10;---&#10;&#10;## Testing the Implementation&#10;&#10;### Test 1: Anonymous Access (Should Fail)&#10;```bash&#10;curl -X POST http://localhost:8080/api/product \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;productName&quot;:&quot;Test&quot;,...}'&#10;&#10;# Expected: 401 Unauthorized&#10;```&#10;&#10;### Test 2: Authenticated Create (Should Succeed)&#10;```bash&#10;curl -X POST http://localhost:8080/api/product \&#10;  -H &quot;Authorization: Bearer &lt;valid-jwt-token&gt;&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;productName&quot;:&quot;Lost Keys&quot;,&quot;typeOfReport&quot;:&quot;LOST&quot;,...}'&#10;&#10;# Expected: 200 OK with product data&#10;```&#10;&#10;### Test 3: Update Own Item (Should Succeed)&#10;```bash&#10;curl -X PUT http://localhost:8080/api/product/1 \&#10;  -H &quot;Authorization: Bearer &lt;owner-jwt-token&gt;&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;description&quot;:&quot;Updated description&quot;}'&#10;&#10;# Expected: 200 OK&#10;```&#10;&#10;### Test 4: Update Someone Else's Item (Should Fail)&#10;```bash&#10;curl -X PUT http://localhost:8080/api/product/1 \&#10;  -H &quot;Authorization: Bearer &lt;different-user-jwt-token&gt;&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;description&quot;:&quot;Malicious update&quot;}'&#10;&#10;# Expected: 403 Forbidden - &quot;You are not authorized to update this product&quot;&#10;```&#10;&#10;---&#10;&#10;## Database Schema Enforcement&#10;&#10;The `Product` table has a foreign key to `User`:&#10;```sql&#10;CREATE TABLE product (&#10;  id BIGINT PRIMARY KEY,&#10;  product_name VARCHAR(255) NOT NULL,&#10;  ...&#10;  user_id BIGINT NOT NULL,  -- Foreign key to user table&#10;  FOREIGN KEY (user_id) REFERENCES user(id)&#10;);&#10;```&#10;&#10;This ensures:&#10;- Every product MUST have an owner&#10;- Referential integrity at database level&#10;- Cascading deletes can be configured if users are deleted&#10;&#10;---&#10;&#10;## Files Modified&#10;&#10;1. **ProductController.java**&#10;   - Extracts authenticated user from `SecurityContext`&#10;   - Passes authenticated email to service layer&#10;&#10;2. **ProductService.java**&#10;   - Interface updated to accept `authenticatedUserEmail` parameter&#10;&#10;3. **ProductServiceImp.java**&#10;   - Uses authenticated email for product creation&#10;   - Adds authorization checks for update/delete&#10;   - Prevents ownership transfers&#10;&#10;4. **SecurityConfig.java**&#10;   - Configured to protect all `/api/**` endpoints&#10;   - Stateless session management&#10;   - JWT filter integration&#10;&#10;5. **JwtAuthenticationFilter.java**&#10;   - Intercepts requests&#10;   - Validates JWT tokens&#10;   - Populates `SecurityContext` with user details&#10;&#10;---&#10;&#10;## Summary&#10;&#10;✅ **The requirement is FULLY IMPLEMENTED:**&#10;- Only logged-in users can create lost/found items&#10;- Item ownership is automatically assigned from JWT token&#10;- Users cannot create items for other users&#10;- Users can only modify/delete their own items&#10;- Full accountability and traceability is maintained&#10;&#10;The system is secure and ready for production use!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/spring-api/nexus/src/main/java/com/nexus/nexus/Enumaration/Status.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/spring-api/nexus/src/main/java/com/nexus/nexus/Enumaration/Status.java" />
              <option name="originalContent" value="package com.nexus.nexus.Enumaration;&#10;&#10;public enum Status {&#10;    OPEN,&#10;    MATCHED,&#10;    DELIVERED&#10;}&#10;" />
              <option name="updatedContent" value="package com.nexus.nexus.Enumaration;&#10;&#10;public enum Status {&#10;    OPEN,&#10;    MATCHED,&#10;    DELIVERED&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>